# 0bをつけると2進数として解釈
print(0b101)

# bin関数で2進数に変換
print(bin(5))

# 16進数から2進数
print(bin(0x12))

# 2進数から16進数
print(hex(0b10010))


# シフト（桁をずらす）
# 左に1つシフト
print(bin(5 << 1))
# 右に1つシフト
print(bin(5 >> 1))


# 論理積(両方1の部分だけが1になる) AND
print(bin(0b10010010 & 0b10100111))

# 論理和(どちらかが1なら1になる) OR
print(bin(0b10010010 | 0b10100111))

# 排他的論理和(片方が1なら1になる（両方1は0）) XOR
print(bin(0b10010010 ^ 0b10100111))
# 同じ値で2回XORするともとに戻る
print(bin(0b10010010 ^ 0b10100111 ^ 0b10100111))


# 反転 NOT
# この場合000...001 -> 111...110になる
print(~1)


# 使用例
# ビットマスク（欲しい部分だけ1を立てて論理積する）
# 下3ビットを取り出す
print(bin(0b10010010 & 0b00000111))
# シフトを組み合わせると真ん中も取得できる(この場合2つずらしている)
print(bin(0b10010010 >> 2 & 0b00000111))
# NOTを組み合わせると反転するため1を立てた部分だけ論理積で削除できる
print(bin(0b10010010 & ~0b00000111))

# ビットの合成
# シフトを使うｋとで並べて1つの値に合成できる
print(bin((0b101 << 3) | 0b110))

# ANDで0に消してから合成もできる
# この場合下3ビットを0にして削除→その後3ビットを合成している(011の部分)
# この手法は画像の生成で背景と対象の合成などで使われる
print(bin(0b101101 & 0b111000 | 0b011))

# XORを使うと異なるものが見つかる（0と0, 1と1は0になるため）
print(bin(0b11101011101110101 ^ 0b11101101101110101))


# 掛け算
# 2進数は桁が上がるごとに2倍になる
# つまり左シフトは2^nになる
# nビットの左シフトは2^nの掛け算

# 割り算
# nビットの右シフトは2^nの割り算（切り捨て）になる

# 割り算のあまり
# 2^nによる割り算のあまりは2^n - 1とのANDに等しい
# 3ビットの右シフトは2^3での割り算になる = 8での割り算
# 押し出された下3ビットが割り算のあまりに相当し、111でマスクすると取り出せる(111は7であり2^n -1となる)
print(bin(0b11001 >> 3))
# 下2は同値
print(bin(0b11001 & 0b111))
print(0b11001 % 8)


# 切り下げ
# 下位nビットのクリアは2^nでの切り下げに相当する
# 3ビット押し出して（右シフト）もとのビット幅に戻す（左シフト）(単純にビットで切り下げする)
print(15 >> 3 << 3)
print(16 >> 3 << 3)
print(17 >> 3 << 3)

# 特定のビットを削除するにはANDとNOTを組み合わせる
# これで上のと同じことをしている(切り捨てる下位3ビットは0b111=7のため(これの反転の論理積により切り下げしている))
print(15 & ~0b111)
print(16 & ~0b111)
print(17 & ~0b111)
